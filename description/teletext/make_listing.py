import os
import json

script_dir = os.path.dirname(os.path.realpath(__file__))

# Get a list of files from the pages directory.
pages_dir = os.path.join(script_dir, "pages")
page_filenames = os.listdir(pages_dir)

filepath = os.path.join(script_dir, "pages.json")

def LoadRaw(filename):
    """
    Load raw files from edit.tf (Raw 0x00-0x7f)
    ZXNet calls this "Binary dump of Level 1 Page Data"
    Convert to edit.tf's base64 implementation
    """

    with open(filename, "rb") as f:
        # Now 24 lines of 40 characters follow (the header is omitted)
        data = bytearray(f.read())
    
    # Identify whether this file has LF or CRLF line endings, or none at all
    if len(data) == (24*40) or len(data) == (25*40):
        # raw data, no CRLF
        data_lines = [data[i:i+40] for i in range(0, len(data), 40)]
    elif len(data) == (24*41) or len(data) == (25*41):
        # raw data with LF line endings
        data_lines = [data[i:i+40] for i in range(0, len(data), 41)]
    elif len(data) == (24*42) or len(data) == (25*42):
        # raw data with CRLF line endings
        data_lines = [data[i:i+40] for i in range(0, len(data), 42)]
    else:
        raise IOError(f"Invalid Teletext-Raw file: {filename}")
    
    b64 = [0 for i in range(1167)]
    # Construct a base-64 array by iterating over each character in the frame.
    for row in range(25):
        for col in range(40):
            for bit in range(7):
                # How many bits into the frame information we are.
                frame_bit = 7 * ((row * 40) + col) + bit

                # Work out the position of the character in the base-64 encoding and the bit in that position.
                b64_bit_offset = frame_bit % 6
                b64_char_offset = int((frame_bit - b64_bit_offset) / 6)

                # Read bit, write bit.
                bit_val = data_lines[row][col] & (1 << (6 - bit))
                b64[b64_char_offset] |= min(bit_val, 1) << (5 - b64_bit_offset) 
    
    #Encode each char
    encoding = "0:"
    for char in b64:
        encoding += "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"[char]
    
    return encoding

print("Generating listing...")

# Page list.
pages = []
for page_filename in page_filenames:
    page_number = int(page_filename[1:4])
    path = os.path.normpath(f"{pages_dir}/{page_filename}")
    pages.append({
        "number": page_number,
        "name": ' '.join(page_filename.split('.')[0].split('-')[1:]),
        "path": path.replace(script_dir + "/", ""),
        "image": "images/" + str(page_number) + ".png",
        "data": LoadRaw(path)
    })
pages.sort(key=lambda p: p["number"])

print("Writing page listing to {}...".format(filepath))
f = open(filepath, "w")
f.write(json.dumps(pages, separators=(',', ':')))
f.close()

def make_title(page):
    return f'P{page["number"]}: {page["name"]}'

print("Writing HTML pages...")
html_dir = os.path.join(script_dir, "html")
if not os.path.exists(html_dir):
    os.makedirs(html_dir)
disclaimer = "<!-- This page is autogenerated by make_listing.py. Do not edit this page. Edit the teletext page(s), page.template, or make_listing.py instead. -->\n\n\n"
with open(os.path.join(script_dir, "page.template"), "rb") as f:
    # Now 24 lines of 40 characters follow (the header is omitted)
    template= f.read().decode("utf8")
for p in range(len(pages)):
    page = pages[p]
    title = make_title(page)
    print(title)
    img = f'<img id="P{page["number"]}" src="../{page["image"]}" alt="{title}"/>'
    if p > 0:
        lastpage = pages[p - 1]
        img += f'\n<a href="{lastpage["number"]}.html" title="{make_title(lastpage)}" id="last"></a>'
    if p + 1 < len(pages):
        nextpage = pages[p + 1]
        img += f'\n<a href="{nextpage["number"]}.html" title="{make_title(nextpage)}" id="next"></a>'
    html = disclaimer + template.replace("--PAGE--", img).replace("--TITLE--", title)
    f = open(os.path.join(html_dir, str(page["number"]) + ".html"), "w")
    f.write(html)
    f.close()    
print("Rules page")
rules = ""
for page in [page for page in pages if page["number"] >= 800]:
    rules += f'<img id="P{page["number"]}" src="../{page["image"]}" alt="P{page["number"]}: {page["name"]}"/>\n'
html = disclaimer + template.replace("--PAGE--", rules).replace("--TITLE--", "TPP Rules")
f = open(os.path.join(html_dir, "rules.html"), "w")
f.write(html)
f.close()

print("Finished.")
